# 벨만-포드 알고리즘(Bellman-Ford Algorithm)

> 다익스트라 알고리즘과 달리 음의 가중치를 가진 간선에 대해서도 최단 거리를 구할 수 있음.



#### 전제 조건

1. 최단 경로는 사이클을 포함할 수 없으므로 최대 |V|-1개의 간선만 사용 가능.
2. 최단 거리가 업데이트 되는 노드가 없어질 때까지 반복.
   - V개의 정점에 대해 E번 반복.
   - **음의 가중치로 인해 최단 거리가 무한히 짧아지는 경우, 최단 거리는 없는 것으로 함.**
3. 모든 정점에 대해 최단 거리를 무한대로 설정.
   - 시작점의 최단 거리만 0으로 초기화.



```c++
bool BellmanFord(int src) {
  for(int i=1; i<=N; i++) {
    dist[i] = INT_MAX;
  }
  dist[src] = 0;
  for(int i=1; i<N; i++) {
    for(int j=0; j<M; j++) {
      int u = bus[j].src;
      int v = bus[j].dest;
      int c = bus[j].weight;
      if(dist[u] != INT_MAX && (dist[u] + c < dist[v]) ) {
        dist[v] = dist[u] + c;
      }
    }
  }
  /*
  모든 정점에 대해 모든 간선을 탐색하며 최단 거리를 업데이트 했기 때문에 더 이상 업데이트 되는 최단 거리가 없어야 함.
  최단 거리가 추가적으로 업데이트 될 수 있다면 음의 가중치로 인한 사이클이 존재함을 알 수 있음.
  */
  for(int i=0; i<M; i++) {
    int u = bus[i].src;
    int v = bus[i].dest;
    int c = bus[i].weight;
    if(dist[u] != INT_MAX && dist[u] + c < dist[v]) {
      return 0;
    }
  }
  return 1;
}
```

[벨만-포드 알고리즘 참고](https://www.crocus.co.kr/535?category=209527)