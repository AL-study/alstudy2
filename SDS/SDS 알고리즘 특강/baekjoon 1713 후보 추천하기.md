### 1713. 후보 추천하기

#### 참고 출처: [꾸준함님 블로그](https://jaimemin.tistory.com/875)

#### 문제

월드초등학교 학생회장 후보는 일정 기간 동안 전체 학생의 추천에 의하여 정해진 수만큼 선정된다. 그래서 학교 홈페이지에 추천받은 학생의 사진을 게시할 수 있는 사진틀을 후보의 수만큼 만들었다. 추천받은 학생의 사진을 사진틀에 게시하고 추천받은 횟수를 표시하는 규칙은 다음과 같다.

1. 학생들이 추천을 시작하기 전에 모든 사진틀은 비어있다.
2. 어떤 학생이 특정 학생을 추천하면, 추천받은 학생의 사진이 반드시 사진틀에 게시되어야 한다.
3. 비어있는 사진틀이 없는 경우에는 현재까지 추천 받은 횟수가 가장 적은 학생의 사진을 삭제하고, 그 자리에 새롭게 추천받은 학생의 사진을 게시한다. 이때, 현재까지 추천 받은 횟수가 가장 적은 학생이 두 명 이상일 경우에는 게시된 지 가장 오래된 사진을 삭제한다.
4. 현재 사진이 게시된 학생이 다른 학생의 추천을 받은 경우에는 추천받은 횟수만 증가시킨다.
5. 사진틀에 게시된 사진이 삭제되는 경우에는 해당 학생이 추천받은 횟수는 0으로 바뀐다.

후보의 수 즉, 사진틀의 개수와 전체 학생의 추천 결과가 추천받은 순서대로 주어졌을 때, 최종 후보가 누구인지 결정하는 프로그램을 작성하시오.

#### 입력

첫째 줄에는 사진틀의 개수 N이 주어진다. (1≤N≤20) 둘째 줄에는 전체 학생의 총 추천 횟수가 주어지고, 셋째 줄에는 추천받은 학생을 나타내는 번호가 빈 칸을 사이에 두고 추천받은 순서대로 주어진다. 총 추천 횟수는 1,000번 이하이며 학생을 나타내는 번호는 1부터 100까지의 자연수이다.



- 알고리즘이라기 보다 시뮬레이션이다. 과정이 조금 복잡한데, 추천 수가 같을 경우, 시간 순으로 액자를 구성해야하기 때문이다. 많은 시간을 고민한 결과 나왔던 코드는 해당 벡터에 모두 때려박는 방법이었다. 하지만 들어가야할 요소가 한 두개가 아니었다. 시간, 번호, 추천수, 액자의 유무로 `vector<pair<pair<int,int>,pair<int,int> > > v`가 탄생했다. 그렇다. 누가봐도 아니다. 결국 풀이를 참고하여 풀었다.

- 추천수를 int배열에 나누어 저장했고, 벡터엔 시간, 번호로만 저장해 하나의 pair로 해결했다. 그렇다면 액자는 어디에 저장했을까? n개를 받기 때문에 0번부터 n-1번까지는 액자에 있는 것으로 간주해서 변수를 줄였다. 많은 요소를 고려해야할 때 나누어 저장하고, 불필요한 요소를 줄인 것이 인상적이었다.

- ```c++
  #include <iostream>
  #include <vector>
  #include <algorithm>
  using namespace std;
  // 해당 번호의 추천수 
  int n,m,reco[101];
  // 시간, 번호 
  vector<pair<int,int> > v(100);
  
  int main(){
  	cin>>n>>m;
  	for(int i=0;i<m;i++){
  		int num;
  		cin>>num;
  		bool replace=true;
  		reco[num]++;
  		for(int j=0;j<n;j++){
  			// 액자가 비어있는 경우 
  			if(v[j].second==0){
  				v[j].second=num;
  				v[j].first=i;
  				replace=false;
  				break;
  			}
  			// 액자에 이미 있는 경우
  			if(v[j].second==num){
  				replace=false;
  				break;
  			} 	
  		}
  		if(replace){
  			// idx를 0 부터 갱신하면서 비교 
  			int idx=0;
  			for(int j=1;j<n;j++){
  				//추천수가 같을 경우는 시간이 오래된 순으로 갱신 
  				if(reco[v[j].second]==reco[v[idx].second]){
  					if(v[j].first<v[idx].first){
  						idx=j;
  					}
  				}
  				//추천수가 다를 경우는 추천수가 적은 순으로 갱신 
  				else if(reco[v[j].second]<reco[v[idx].second]){
  					idx=j;
  				}
  			}
  			reco[v[idx].second]=0;
  			v[idx].first=i;
  			v[idx].second=num;
  		}
  	}
  	vector<int> ans;
  	for(int i=0;i<n;i++){
  		ans.push_back(v[i].second);
  	}
  	sort(ans.begin(),ans.end());
  	for(int i=0;i<n;i++){
  		cout<<ans[i]<<" ";
  	}
  }
  ```

  