# SDS 5일차 조합론

> #### Kewords
>
> `파스칼의 삼각형`	 `BFS`	 `비트마스킹`	  `DP` 	`순열`	  `백트래킹` 	 ...etc

BOJ 11050 이항 계수1, BOJ 11051 이항 계수 2, BOJ 1010 다리 놓기는 파스칼의 삼각형의 기본 구현이므로 생략.

***



### [1256 사전][1256 사전]

- a와 z로 이루어진 문자열 중 K번째 문자열.
- 파스칼의 삼각형을 이용해 조합의 수를 계산하고, K의 임계값인 10<sup>9</sup> 을 넘는다면 MAX 값으로 저장.
- 조합의 수가 K보다 작다면 -1 출력.
- K보다 <sub>n+m-1</sub>C<sub>m</sub> 이 크거나 같다면 a를 출력하고 n--.
- 그 외는 z를 출력하고 m--.



***



### [5568 카드 놓기][5568 카드 놓기]

- 카드에 적힌 숫자 입력받은 후 정렬.
- 조합을 이용해 숫자 선택 후, string으로 이어붙여 set 에 넣음.
  - set은 자동으로 중복제거 및 정렬됨.



***



### [5573 산책][5573 산책]

- (1,1) 지점은 N번의 산책동안 계속 밟기 때문에 N으로 초기화.
- 한 지점을 기준으로 오른쪽 / 아래쪽으로 절반씩 이동하므로 `dp[i][j]` 의 절반 값을 인접한 지점에 저장.
  - 홀수인 경우는 기존 방향에 한 번 더 가므로 +1.
- dp 값을 mod 2 한 값으로 변환.
- 처음에 받은 map 값을 따라가며 dp 값을 확인해 좌표 이동.



***



### [5569 출근 경로][5569 출근 경로]

- 현재 방향으로 올 때의 방향과 방향 전환 가능 여부를 판별하여 DP 값 계산.

```c++
//dp[i][j][d][t] => (i,j)로 올 때의 방향과 방향 전환 가능 여부.

for(int i=2; i<=w; i++) {
  for(int j=2; j<=h; j++) {
    //같은 방향에서 온 경우 방향 전환 가능.
    dp[i][j][0][0] = (dp[i-1][j][0][0] + dp[i-1][j][0][1]) % 100000;
    //방향을 전환해서 온 경우 방향 전환 불가능.
    dp[i][j][0][1] = dp[i-1][j][1][0];
    dp[i][j][1][0] = (dp[i][j-1][1][0] + dp[i][j-1][1][1]) % 100000;
    dp[i][j][1][1] = dp[i][j-1][0][0];
  }
}
```



***



### [1722 순열의 순서][1722 순열의 순서]

- 순열이 주어지면 몇 번째 순열인지, K가 주어지면 K번째 순열 구하기.
- 숫자의 수가 최대 20개이므로 20!까지 미리 구해둠.
- K번째 순열 구하기.
  - i번째 자리는 (N-i)!을 K보다 작거나 같을 때까지 빼면 어떤 숫자인지 알 수 있음.
  - 숫자는 중복되지 않으므로 이미 앞에서 나온 숫자라면 continue.
- 몇 번째 순열인지 구하기.
  - 숫자 입력받으면서 방문 배열 1로 만듦.
  - 입력받은 숫자보다 작으면서 방문하지 않은 숫자만큼 (N-i)! 더하기.
  - 마지막 자리까지 다 구한 뒤, 현재의 순열을 포함해야 하므로 +1.



***



### [13251 조약돌 꺼내기][13251 조약돌 꺼내기]

- 50!은 long long도 초과하므로, 확률의 분수를 바로바로 곱해서 계산.



***



### [15663 N과 M (9)][15663 N과 M (9)]

- 재귀를 이용해 사용하지 않은 숫자를 골라 조합을 만듦.
- M개를 선택했다면, 조합들을 담고 있는 벡터에 해당 조합이 존재하는지 판별 후 넣음.
  - 방문배열 초기화.
- 재귀로 들어가기 전에 현재 선택된 숫자와 조합을 저장해둔 뒤, 재귀가 끝나면 다시 재귀 전의 상태로 돌림.



***



### [15664 N과 M (10)][15664 N과 M (10)]

- [N과 M (9)](#15663-N과-M-9) 와 같은 방식이나 비내림차순으로 선택 필요.

```c++
for(int i=idx; i<N; i++) {
    if(!visited[i]) {
      comb[depth] = num[i];
      visited[i]=1;
      select(depth+1, i+1); //선택된 idx 이후부터 선택하기 위해
      for(int j=0; j<M; j++) {
        comb[j] = temp[j];
      }
      for(int j=0; j<9; j++) {
        visited[j] = chk[j];
      }
    }
  }
```



***



[1256 사전]: ./BOJ1256%20사전.cpp "BOJ 1256 사전 소스 코드"
[5568 카드 놓기]: ./BOJ5568%20카드%20놓기.cpp "BOJ 5568 카드 놓기 소스 코드"
[5573 산책]: ./BOJ5573%20산책.cpp "BOJ 5573 산책 소스 코드"
[5569 출근 경로]: ./BOJ5569%20출근경로.cpp "BOJ 5569 출근 경로 소스 코드"
[1722 순열의 순서]: ./BOJ1722%20순열의%20순서.cpp "BOJ 1722 순열의 순서 소스 코드"
[13251 조약돌 꺼내기]: ./BOJ13251%20조약돌%20꺼내기.cpp "BOJ 13251 조약돌 꺼내기 소스 코드"
[15663 N과 M (9)]: ./BOJ15663%20N과%20M%20(9).cpp "BOJ 15663 N과 M (9) 소스 코드"
[15664 N과 M (10)]:./BOJ15664%20N과%20M%20(10).cpp "BOJ 15664 N과 M (10) 소스 코드"
[9663 N-Queen]:./BOJ9663%20N-QUEEN.cpp "BOJ 9663 N-Queen 소스 코드"
[1759 암호 만들기]: ./BOJ1759%20암호%20만들기.cpp "BOJ 1759 암호 만들기 소스 코드"
[2580 스도쿠]:./BOJ2580%20스도쿠.cpp "BOJ 2580 스도쿠 소스 코드"
[1339 단어 수학]: ./BOJ1339%20단어%20수학.cpp	"BOJ 1339 단어 수학 소스코드"