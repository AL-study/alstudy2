# SDS 1일차 알고리즘 기초

> #### Kewords
>
> `시뮬레이션`	 `BFS`	 `비트마스킹` 	 `DP  ` 	`이분탐색`	  `백트래킹` 	 ...etc



***



### [3425 고스택][3425 고스택]

- 스택을 응용해 고스택 만들기.
  - 고스택에는 10<sup>9</sup> 이하의 수만 들어갈 수 있음.
  - MUL 연산에서 int 범위를 초과할 수 있으므로 연산 시 long long으로 type casting 하여 범위를 초과하는지 판별해야 함.



***



### [3055 탈출][3055 탈출]

- 고슴도치가 비버의 굴로 도망갈 수 있는지, 도망치는 데 걸리는 최소 시간이 얼마인지.
  - 물과 고슴도치는 각각의 BFS 로 이동.
    - 한 턴마다 기존의 queue에 사이즈만큼만 돌려야 함.



***



### [1062 가르침][1062 가르침]

- K개의 글자를 가르쳐서 학생들이 읽을 수 있는 단어 개수의 최대값 찾기.
  - 기본적으로 `a, c, i, n, t`  5개의 단어는 알아야 함.
  - 그 외의 글자는 비트마스킹으로 경우의 수 추릴 수 있음.

```c++
//i번째 bit의 flag가 켜져있지 않다면 1로 on.
for(int i=idx; i<26; i++) {
  if(!(flag & (1<<i))) solve(i, flag|(1<<i), cnt+1);
}
```



***



### [1713 후보 추천하기][1713 후보 추천하기]

- 사진틀에 사진이 걸릴 최종 후보 추리기.
  - 추천을 받을 때마다 사진틀에 걸린 사진이 달라질 수 있음.
  - 사진틀에 걸린 후보들은 vector로 관리.
    - 사진틀에 존재한다면 추천수만 증가.
    - 존재하지 않고, 사진틀에 걸린 사진보다 사진틀에 개수가 많은 경우 벡터에 push_back
    - 존재하지 않고 사진틀이 다 차있다면 가장 추천수가 적은 사람 erase, erase한 사람의 추천수 0으로 초기화 후 새로운 후보 push_back



***



### [1103 게임][1103 게임]

- 보드에서 동전을 움직일 수 있는 최대 회수.
  - 보드에서 동전이 방문한 visited 배열과, 사이클을 확인할 finished 배열.
  - x, y로 움직였을 때 `visitied[x][y] = 1` 로 변경.
    - 위아래, 왼쪽 오른쪽에서 갈 수 있는 방향을 탐색.
    - 모든 방향을 탐색한 뒤에 `finished[x][y] = 1`
      - 중간에 사이클이 있었다면 인접한 방향으로 DFS를 돌리다가 x, y를 다시 만나기 때문.



***



### [1039 교환][1039 교환]

- 주어진 수를 i번과 j번 위치 숫자를 바꿔 만들 수 있는 수의 최대값.
  - queue에서 숫자를 꺼내 i,j번째 위치를 고르고 둘의 위치를 바꾼 적이 있는지 체크.
    - 없다면 위치 바꾼 뒤 queue에 push.
  - queue에서 숫자를 꺼낼 때마다 방문 배열 초기화.



***



### [1920 수 찾기][1920 수 찾기]

- 배열이 주어졌을 때 주어진 정수가 존재하는지 탐색.
  1. 배열을 정렬.
  2. 탐색할 범위를 start = 0, end = N-1 로 시작해 mid의 배열 값을 기준으로 탐색 범위를 반으로 줄여나감.



***



### [9663 N-Queen][9663 N-Queen]

- 체스판에서 N개의 Queen 이 서로 공격할 수 없도록 퀸을 배치하는 방법의 수.

  - 체스에서 퀸은 가로, 세로, 대각선 거리 상관없이 모두 움직일 수 있음.

  1. 체스판의 크기가 최대 15이므로, 크기가 16인 1차원 배열을 선언.
     - 행마다 퀸의 위치를 저장하는 방식으로써 2차원이 아닌 1차원 배열 사용.
  2. 행별로 퀸을 하나씩 위치시키며 해당 행 이전에 위치한 퀸과 일직선 상에 위치하는지 확인.
     - 값이 같거나 기울기의 절대값이 1이라면 일직선 상이므로 탐색 종료.



***



### [1759 암호 만들기][1759 암호 만들기]

- 최소 한 개의 모음과 최소 두 개의 자음으로 구성되며 알파벳이 증가하는 순으로 이루어진 암호 만들기.
  - [가르침](#1039-가르침)과 동일한 방식으로 비트 마스킹.

```c++
//알파벳이 증가하는 순으로 선택되어야 하기 때문에 idx 부터 주어진 알파벳 길이까지 탐색.
for(int i=idx; i<C; i++) {
  solve(bits|(1<<i), i+1, cnt+1);
}
```



***



### [2580 스도쿠][2580 스도쿠]

- 스도쿠의 비어있는 칸을 채워 주어진 보드 완성.
  1. 비어있는 칸에 1~9까지 하나씩 넣어봄.
  2. 가로, 세로, 구분된 정사각형 내에서 중복되는 수가 없는지 확인.
  3. 가능한 수라면 해당 수를 채운 뒤 다음 칸으로 넘어감.
  4. 불가능하다면 false 리턴해 다시 해당 값은 0으로 초기화.
  5. 재귀로 모든 빈 칸이 채워지면 break.
     - 방법이 여러 가지인 경우 하나만 출력하므로 정답이라면 출력 후, 탐색 종료.



***



### [1339 단어 수학][1339 단어 수학]

- 각 알파벳을 한 자리수로 치환해 덧셈연산을 할 때, 얻을 수 있는 최대값 찾기.
  1. 알파벳 별로 자리수에 따른 가중치를 계산해 배열에 넣음.
  2. 가중치가 큰 알파벳부터 9~0 순으로 숫자 배당.



***



[3425 고스택]: ./BOJ3425%20고스택.cpp "BOJ 3425 고스택 소스 코드"
[3055 탈출]: ./BOJ3055%20탈출.cpp "BOJ 3055 탈출 소스 코드"
[1062 가르침]: ./BOJ1062%20가르침.cpp "BOJ 1062 가르침 소스 코드"
[1713 후보 추천하기]: ./BOJ1713%20후보%20추천하기.cpp "BOJ 1713 후보 추천하기 소스 코드"
[1103 게임]: ./BOJ1103%20게임.cpp "BOJ 1103 게임 소스 코드"
[1039 교환]: ./BOJ1039%20교환.cpp "BOJ 1039 교환 소스 코드"
[1920 수 찾기]: ./BOJ1920%20수%20찾기.cpp "BOJ 1920 수 찾기 소스 코드"
[9663 N-Queen]:./BOJ9663%20N-QUEEN.cpp "BOJ 9663 N-Queen 소스 코드"
[1759 암호 만들기]: ./BOJ1759%20암호%20만들기.cpp "BOJ 1759 암호 만들기 소스 코드"
[2580 스도쿠]:./BOJ2580%20스도쿠.cpp "BOJ 2580 스도쿠 소스 코드"
[1339 단어 수학]: ./BOJ1339%20단어%20수학.cpp	"BOJ 1339 단어 수학 소스코드"