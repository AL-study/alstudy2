# MST (Minimum Spanning Tree) 최소 신장 트리



#### 참고 출처:

####  https://gmlwjd9405.github.io/2018/08/28/algorithm-mst.html (MST 개념)

####  https://blog.naver.com/ndb796/221230994142 (크루스칼 알고리즘)

####  https://ko.m.wikipedia.org/wiki/ (프림 알고리즘)



최소 신장 트리를 공부하기 이전에 신장 트리(Spanning Tree)가 무엇인지 알아야 한다. **신장 트리는 그래프의 최소 연결 부분 그래프**이다. N개의 정점을 가지는 그래프를 최소의 간선 수로 이으려면 몇 개가 필요할까? N개의 정점을 일렬로 줄 세우고 근접한 정점을 하나의 간선으로 이어보자. **N개의 정점을 가지는 그래프는 최소 N-1개의 간선**으로 이을 수 있다는 것을 알 수 있다. 

![](https://gmlwjd9405.github.io/images/algorithm-mst/spanning-tree.png)

- DFS, BFS를 이용하여 그래프에서 신장 트리를 찾을 수 있따.
  - 탐색 도중에 사용된 간선만 모으면 만들 수 있다.
- 하나의 그래프에는 많은 신장 트리가 존재할 수 있다.
- Spanning Tree는 트리의 특수한 형태이므로 **모든 정점들이 연결** 되어 있어야 하고 **사이클을 포함해서는 안된다.**
- 따라서 Spanning Tree는 그래프에 있는 **n개의 정점을 정확히 (n-1)개의 간선으로 연결** 한다.



**MST는 이러한 스패닝 트리중 간선들의 가중치 합이 최소인 트리**를 말한다. 스패닝 트리중 최소의 가중치 합을 갖는 트리이기 때문에 스패닝 트리의 특징을 그대로 갖는다.

1. 간선의 가중치의 합이 최소여야 한다.
2. n개의 정점을 가지는 그래프에 대해 반드시 (n-1)개의 간선만을 사용해야 한다.
3. 사이클이 포함되어서는 안된다.



### MST의 사용 사례

통신망, 도로망, 유통망에서 길이, 구축 비용, 전송 시간 등을 최소로 구축하려는 경우

- 도로 건설
  - 도시들을 모두 연결하면서 도로의 길이가 최소가 되도록 하는 문제

- 전기 회로
  - 단자들을 모두 연결하면서 전선의 길이가 가장 최소가 되도록 하는 문제

- 통신
  - 전화선의 길이가 최소가 되도록 전화 케이블 망을 구성하는 문제
- 배관
  - 파이프를 모두 연결하면서 파이프의 총 길이가 최소가 되도록 연결하는 문제



### MST의 구현 방법



#### 1. 크루스칼 알고리즘

탐욕적인 방법을 이용하여 네트워크의 모든 정점을 최소 비용으로 연결하는 최적의 해답을 구하는 방법이다. 핵심은 **사이클을 발생시키지 않는 최소 가중치의 간선만을 선택**하여 최소 신장 트리를 만드는 것이다. 다음과 같은 방법으로 구현할 수 있다.

 	1. 정렬된 순서에 맞게 그래프에 포함시킨다.
   	2. 포함시키기 전에는 사이클유무를 확인한다.
   	3. 사이클을 형성하는 경우 간선을 포함하지 않는다.

#### 시간 복잡도

사이클을 유무를 알기 위해선 **유니온 파인드**를 이용한다. 그러나 유니온 파인드는 많은 시간이 걸리는 알고리즘은 아니기 때문에 보통 **간선을 정렬하는 과정이 크루스칼 알고리즘의 시간 복잡도를 결정**한다. 효율적인 정렬 알고리즘을 쓴다면 보통 O(nlgn)에 가능하기 때문에 크루스칼 알고리즘의 시간 복잡도는 **간선의 수를 e라고 할 때O(ElogE)이라고 할 수 있다. **



#### 2. 프림 알고리즘

크루스칼 알고리즘이 최소의 간선을 선택하는 탐욕적인 방법이라면 프림 알고리즘은 **선택한 정점을 기준으로 최소의 가중치를 갖는 정점을 선택**하는 방법이다. 다음과 같은 방법으로 구현할 수 있다.

1. 그래프에서 하나의 꼭짓점을 선택하여 트리를 만든다.
2. 그래프의 모든 변이 들어 있는 집합을 만든다.
3. 모든 꼭짓점이 트리에 포함되어 있지 않은 동안 1. 트리와 연결된 변 가운데 트리 속의 두 꼭짓점을 연결하지 않는 가장 가중치가 작은 변을 트리에 추가한다.

#### 시간 복잡도

단순히 간선과 정점만을 가지고 프림 알고리즘을 사용하면 n개의 정점에 대해 n번 반복문을 사용하므로 O(n^2)이다. 그러나 **이진 힙을 사용하여 자료를 처리하였을 때 o(ElogV)의 시간복잡도를 갖는다. 그래프가 충분히 빽빽한 경우에는 피보나치 힙을 이용하여 훨씬 빠르게 구할 수 있다고 한다. 이 방법은 복잡도가 O(E+VlogV)까지 떨어진다.**



## 문제 리스트

- ### [BOJ 1922 네트워크 연결](https://github.com/jungtaeyong/alstudy2/blob/ty/SDS/예습/baekjoon%201922%20네트워크%20연결.md)

