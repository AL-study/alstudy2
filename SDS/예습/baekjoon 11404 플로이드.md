### 11404. 플로이드



#### 문제

n(1 ≤ n ≤ 100)개의 도시가 있다. 그리고 한 도시에서 출발하여 다른 도시에 도착하는 m(1 ≤ m ≤ 100,000)개의 버스가 있다. 각 버스는 한 번 사용할 때 필요한 비용이 있다.

모든 도시의 쌍 (A, B)에 대해서 도시 A에서 B로 가는데 필요한 비용의 최솟값을 구하는 프로그램을 작성하시오.

#### 입력

첫째 줄에 도시의 개수 n(1 ≤ n ≤ 100)이 주어지고 둘째 줄에는 버스의 개수 m(1 ≤ m ≤ 100,000)이 주어진다. 그리고 셋째 줄부터 m+2줄까지 다음과 같은 버스의 정보가 주어진다. 먼저 처음에는 그 버스의 출발 도시의 번호가 주어진다. 버스의 정보는 버스의 시작 도시 a, 도착 도시 b, 한 번 타는데 필요한 비용 c로 이루어져 있다. 시작 도시와 도착 도시가 같은 경우는 없다. 비용은 100,000보다 작거나 같은 자연수이다.

시작 도시와 도착 도시를 연결하는 노선은 하나가 아닐 수 있다.



- 플로이드 와샬 알고리즘의 개념과 구현을 연습할 수 있는 좋은 문제.
- 플로이드 와샬 알고리즘은 출발 노드, 거쳐가는 노드, 도착 노드를 기준으로 3번의 반복문을 돌리면서 다이나믹 프로그래밍 기법을 이용해 메모이제이션을 하며 값을 갱신시키는 알고리즘이다. 구현도 어렵지않게 할 수 있다.

- ```C++
  #include <iostream>
  #include <vector>
  #define INF 10000000
  using namespace std;
  
  int arr[101][101],n,m; 
  
  int main(){
  	cin>>n>>m;
  	for(int i=1;i<=n;i++){
  		for(int j=1;j<=n;j++){
  			if(i==j){
  				arr[i][j]=0;
  			}else{
  				arr[i][j]=INF;
  			}
  		}
  	}
  	for(int i=1;i<=m;i++){
  		int a,b,c;
  		cin>>a>>b>>c;
  		if(arr[a][b]){
  			arr[a][b]=min(arr[a][b],c);
  		}else{
  			arr[a][b]=c;
  		}
  	}
  	for(int k=1;k<=n;k++){
  		for(int i=1;i<=n;i++){
  			for(int j=1;j<=n;j++){
  				arr[i][j]=min(arr[i][j],arr[i][k]+arr[k][j]);
  			}
  		}
  	}
  	for(int i=1;i<=n;i++){
  		for(int j=1;j<=n;j++){
  			if(arr[i][j]==INF){
  				cout<<0<<" ";
  			}else{
  				cout<<arr[i][j]<<" ";
  			}
  		}
  		cout<<"\n";
  	}
  }
  
  
  
  ```

  