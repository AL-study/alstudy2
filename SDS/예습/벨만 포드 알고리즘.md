# 벨만 포드 알고리즘

벨만 포드 알고리즘은 한 점에서 다른 모든 점까지의 최단 경로를 찾는 알고리즘이다. 그렇다. 다익스트라 알고리즘과 목적이 같다. 그러나 벨만 포드 알고리즘은 정점과 간선만큼 반복하기 때문에 O(VE)로 O((V+E)lgV)인 다익스트라 알고리즘보다 느리다. 그럼에도 불구하고 벨만 포드 알고리즘을 사용하는 이유가 무엇일까? 답은 **음의 가중치**이다. 다익스트라는 반드시 간선의 가중치가 양수여야 하며, 음수일 경우 성립이 되지 않는다. 그러나 벨만 포드 알고리즘은 간선이 음의 가중치를 갖는 경우도 해결할 수 있다. 그러나 음의 사이클을 갖을 경우 무한하게 값이 작아지므로, 벨만 포드 알고리즘은 첫번째로 **음의 사이클을 판별**할 수 있고, 두번째로 **각 정점의 최단거리**를 구한다. 



과정으 다익스트라와 비슷하게 선택한 정점을 제외하고 나머지를 무한하게 가중치를 설정한 상태에서 갱신하는 방법을 사용한다. 벨만 포드의 개념과 구현을 연습할 수 있는 문제인 [BOJ 11657 타이머신](https://www.acmicpc.net/problem/11657) 문제를 구현하면서 코드를 설명한다.

```C++
#include <iostream>
#include <vector>
#define INF 10000000
using namespace std;
int n,m,d[501];
vector<pair <int, int> > v[501];
bool cycle;
void bellman(){
    // 반복문 i는 음의 사이클을 확인하기 위한 용도이다.
    // 벨만 포드 알고리즘을 수행하고 난뒤에 다시 수행했을 때 값이 갱신된다면 
    // 음의 사이클이 존재하는 경우이다.
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			for(int k=0;k<v[j].size();k++){
                // j정점의 가중치가 INF가 아니면서 이동했을 때의 가중치가 작다면 갱신한다.
				if(d[j]!=INF&&d[v[j][k].first]>v[j][k].second+d[j]){
					d[v[j][k].first]=v[j][k].second+d[j];
					//음의 사이클 존재시 cycle을 true로 변경(flag변수)
                    if(i==n)cycle=true;
				}
			}
		}
	}
	if(cycle)
		cout<<"-1\n";
	else{
		for(int i=2;i<=n;i++){
			if(d[i]==INF)cout<<"-1\n";
			else cout<<d[i]<<"\n";
		}
	}
}

int main(){
	cin>>n>>m;
	for(int i=0;i<m;i++){
		int a,b,c;
		cin>>a>>b>>c;
        // a정점에서 b정점으로 갈 때 가중치는 c이다.
		v[a].push_back({b,c});
	}
    // 문제에선 1번부터 탐색을 시작하므로 탐색하는 정점은 0으로 그대로두고 나머지는 INF로 초기화한다.
	for(int i=2;i<=n;i++){
		d[i]=INF;
	}
	bellman();
}
```



## 문제 리스트

- ### [BOJ 11657 타임머신](https://github.com/jungtaeyong/alstudy2/blob/ty/SDS/예습/baekjoon%2011657%20타임머신.cpp)

