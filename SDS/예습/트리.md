# 트리

트리는 알고리즘보다는 자료구조에 가깝다. 자료구조에서의 트리는 부모-자식 관계로 정의하고, 부모에서 자식으로 간선이 이어져 있는 유향 그래프이다. 트리는 부모가 없는 루트 노드를 가지고 있으며, 이 루트에서 부터 시작되어 가지가 뻗어나간다. 이진트리가 가장 대표적인 트리라고 할 수 있는데, 이러한 이진트리를 이용하여 우선순위 큐 등 삽입, 삭제, 및 탐색 속도를 줄여주기 때문이다. 트리라는 큰 범주에서 다양한 트리로 나눠지기 때문에 문제를 통해서 다양한 트리를 배워보자.



- ### [BOJ 1991 트리](https://github.com/jungtaeyong/alstudy2/blob/ty/SDS/예습/baekjoon%201991%20트리.md)



## 세그먼트 트리

이보다 완벽한 설명은 없다고 생각한다. 

#### [백준님의 완벽한 세그먼트 트리 강의](https://www.acmicpc.net/blog/view/9)  

이진트리를 활용하여 부분합을 구하고, 해당 배열을 갱신하는 과정을 각각 O(lgN)만에 끝내는 매우 효율적인 방법이다. 세그먼트 트리 문제를 풀기 위해서는 총 3가지 함수를 구현해야 한다. 

1. tree 구조를 구축하기 위한 init 함수

```c++
long long init(vector <long long> &arr, vector<long long> &tree, int node, int start, int end){
	if(start==end){
		return tree[node]=arr[start];
	}else{
		return tree[node]=init(arr, tree, node*2,start,(start+end)/2)+init(arr, tree, node*2+1,(start+end)/2+1,end);
	}
}
```



2. 부분합을 구하기 위한 sum 함수

```c++
long long sum(vector<long long> &tree, int node, int start, int end, int left, int right){
	if(left>end||right<start){
		return 0;
	}
	if(left<=start&& end<=right){
		return tree[node];
	}
	return sum(tree, node*2,start,(start+end)/2,left,right)+sum(tree, node*2+1,(start+end)/2+1,end,left,right);
}
```



3. 해당 노드의 값을 바꾸면서 관련된 노드 값을 전부 갱신시켜주는 update 함수

```c++
void update(vector<long long> &tree, int node, int start, int end, int index, long long diff) {
    if (index < start || index > end) return;
    tree[node] = tree[node] + diff;
    if (start != end) {
        update(tree,node*2, start, (start+end)/2, index, diff);
        update(tree,node*2+1, (start+end)/2+1, end, index, diff);
    }
}
```



세그먼트 트리를 활용한다는 것은 이 함수들을 정의해 사용한다는 뜻이다. 반드시 필요한 기능들이기 때문이다. 보통 함수를 구현할 줄 알면 복붙해서 사용한다고 하지만 아직 배우는 단계이므로 문제를 풀 때마다 직접구현해 익숙해져야 할 것이다.



- ### [BOJ 2042 구간 합 구하기](https://github.com/jungtaeyong/alstudy2/blob/ty/SDS/예습/baekjoon%202042%20구간%20합%20구하기.md)

- ### [BOJ 2357 최솟값과 최댓값](https://github.com/jungtaeyong/alstudy2/blob/ty/SDS/예습/baekjoon%202357%20최솟값과%20최댓값.md)