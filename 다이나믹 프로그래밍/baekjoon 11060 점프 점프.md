### 11060. 점프 점프

- 1xN 크기의 미로를 각 칸의 수만큼 점프해 끝까지 갈 수 있는 최소의 횟수를 구하는 문제.

- 계단오르기 문제와 유사하다고 생각했지만 다른 문제이다. 특이하게 현재 dp배열의 값을 이전의 dp배열에서 구하지 않고 현재 dp배열의 값을 이용해 뒤의 dp값을 구한다. 

- 주의사항은 다음과 같다.

  - 최소값을 구해야하기 때문에 적당히 큰 값으로 초기화 해야한다. (주어진 조건을 살펴보자.)
  - 첫 값은 0으로 초기화를 해주어야 한다.
  - 최솟값을 갱신하는 식으로 뒤의 dp배열들을 갱신해준다.
  - 도달하지 못하는 경우도 있다. 이 때의 값은 처음 초기화한 적당히 큰 값일 것이다. 처리해주자.

- ```c++
  #include <iostream>
  using namespace std;
  int n,arr[1001],dp[1001];
  int main(){
  	cin>>n;
  	for(int i=0;i<n;i++){
  		cin>>arr[i];
  	}
  	for(int i=0;i<n;i++){
  		dp[i]=1000000;
  	}
  	dp[0]=0;
  	for(int i=0;i<n;i++){
  		for(int j=1;j<=arr[i];j++){
  			dp[i+j]=min(dp[i+j],dp[i]+1);
  		}
  	}
  	if(dp[n-1]==1000000){
  		cout<<-1;
  	}else{
  		cout<<dp[n-1];
  	}
  }
  ```

  