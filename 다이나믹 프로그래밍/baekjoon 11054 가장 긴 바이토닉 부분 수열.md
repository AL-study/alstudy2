### 11054. 가장 긴 바이토닉 부분 수열 ★★

- 가장 긴 시리즈 증가or 감소의 수열의 응용문제.

- 접근방법이 쉽게 떠오르지 않아 힌트를 보았다. (힌트: 가장 긴 시리즈 증가or 감소의 수열의 응용문제.)

- 처음엔 해당 인덱스를 기준으로 `1~i`까지 가장 긴 증가하는 부분 수열을 구하고 `i~n`까지 가장 긴 감소하는 부분 수열을 구한 합을 생각했다. (i번째가 겹치기 때문에 결과에 1을 뺀다.)

- 풀리지 않아 [코딩과 디버깅 사이님의 블로그]( https://blog.naver.com/occidere/220852732226 )를 참고했고 블로그의 접근방법은  i번째 기준으로 `0~i`번째까지의가장 긴 증가하는 부분수열, n번째부터 i번째까지의 가장 긴 증가하는 부분 수열의 합 -1이었다.

- 언뜻보면 논리가 같아보인다. (같다고 생각하고 30분동안 열심히 삽질했다.) 그러나 `i~n`번째까지의 가장 긴 감소하는 부분수열은 **반드시 i번째를 기준으로 구한 최대값이 아니다.** 예를들어 3 4 3 2 1 의 경우 가장 긴 감소하는 부분수열은 4 3 2 1이다. 첫번째인 3부터 시작하지 않는다. 따라서 오류가 있다. 그러나 `n~i`번째의 가장 긴 증가하는 부분수열은 **i번째를 기준으로 구한 최대값이기 때문에 가능한 것이다.**

- ```c++
  #include <iostream>
  using namespace std;
  int n,arr[1001],dp1[1001],dp2[1001],dp3[1001],ans;
  int main(){
  	cin>>n;
  	for(int i=1;i<=n;i++){
  		cin>>arr[i];
  		dp1[i]=1;
  		dp2[i]=1;
  	}
  	for(int i=1;i<=n;i++){
  		for(int j=1;j<i;j++){
  			if(arr[i]>arr[j]){
  				dp1[i]=max(dp1[i],dp1[j]+1);
  			}
  		}
  	}
  	for(int i=n;i>=1;i--){
  		for(int j=n;j>i;j--){
  			if(arr[i]>arr[j]){
  				dp2[i]=max(dp2[i],dp2[j]+1);
  			}
  		}
  	}
  	for(int i=1;i<=n;i++){
  		ans=max(ans,dp1[i]+dp2[i]-1);
  	}
  	cout<<ans;
  }
  ```

- #### 참고 출처: [코딩과 디버깅 사이님의 블로그]( https://blog.naver.com/occidere/220852732226 )

  