### 14501. 퇴사 ★

- 삼성SW역량 기출문제.
- 완전탐색하여 풀면 풀리지만 DP로도 풀 수 있다. DFS로 풀경우 작업을 하고 안하고 두 가지만 신경쓰면 되기 때문에 어렵지 않을 것이다. N의 범위가 그렇게 크지 않기 때문이다.
- N의 크기가 커진다면 완전탐색만으론 풀 수 없다. DP를 이용해야 한다. DP배열을 정의를 어떻게 내리는가에 따라 풀이법이 조금씩 달라진다. 아래의 풀이에서는 **DP[i]는 i일의 상담업무를 맡았을 때의 최고가격**이라는 전제에서 출발한다. 예를들어 DP[7]은 7일차의 업무를 맡았을 때의 최고가격이다. **7일까지 업무의 최고가격이 아니다.**
- 따라서 `i+t[i]<=n+1`경우만 계산해주어야 한다. 

- 점화식은 `DP[i]=max(DP[i],p[i]+DP[j])`이다. 보통 다이나믹 프로그래밍의 시간복잡도는 O(n)인 경우가 많지만 O(n^2)가 되는 경우 (여러 조건을 생각해야하는 경우) 점화식을 한번에 세우기 어렵고 오랜시간 고민해야한다. 코드는 짧지만 이해하긴 어려운 로직이었다.

- ```c++
  #include <iostream>
  using namespace std;
  int n,dp[21],t[21],p[21];
  int main(){
  	cin>>n;
  	for(int i=1;i<=n;i++){
  		cin>>t[i]>>p[i];
  		dp[i]=p[i];
  	}
  	for(int i=2;i<=n;i++){
  		for(int j=1;j<i;j++){
  			if(t[j]+j<=i){
  				dp[i]=max(dp[i],p[i]+dp[j]);
  			}
  		}
  	}
  	int ans=0;
  	for(int i=1;i<=n;i++){
  		if(t[i]+i<=n+1){
  			ans=max(ans,dp[i]);
  		}
  	}
  	cout<<ans;
  } 
  ```

  