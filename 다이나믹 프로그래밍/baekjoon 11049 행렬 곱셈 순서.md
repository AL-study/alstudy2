### 11049. 행렬 곱셈 순서 ★

- 행렬의 수와 각 행과 열의 수가 주어질 때, 행렬의 순서를 바꾸지 않고 행렬의 곱셈 순서만 바꾸었을때 최소 연산횟수를 구하는 문제.

- 최소횟수를 하나씩 구해나가면 너무 오래걸리기 때문에 메모이제이션을 이용해 dp배열에 값을 값을 저장해 답을 구한다. 먼저 dp를 정의해보자.

  `dp[i][j]= i행부터 j열까지 행렬곱의 최소연산횟수`이다. 따라서 문제에서 원하는 값은 `dp[1][n]`의 값이다.

  이제 `dp[i][j]`를 구해보자. 테스트 케이스를 설정하고 직접 구해보면 알겠지만 간단하게 바로 구할 수는 없다. 그렇다면 문제를 나눠서 생각해보자. 행렬을 2개의 묶음으로 쪼갠다. {i~k}{k+1~j}로 쪼갠다고 가정했을때 `dp[i][j]=dp[i][k]+dp[k+1][j]+a[i][0]+a[k][1]+a[j][1]`이다. k를 증가시키면서 모든 경우의수로 쪼개보면서 답을 구한다.

- ```c++
  #include <iostream>
  using namespace std;
  int n,arr[501][2],dp[501][501];
  int main(){
  	cin>>n;
  	for(int i=1;i<=n;i++){
  		cin>>arr[i][0]>>arr[i][1];
  	}
  	for(int i=1;i<=n-1;i++){
  		dp[i][i+1]=arr[i][0]*arr[i][1]*arr[i+1][1];
  	}
  	for(int l=2;l<=n;l++){
  		for(int i=1;i<=n-l;i++){
  			int j=i+l;
  			for(int k=i;k<j;k++){
  				int temp=dp[i][k]+dp[k+1][j]+arr[i][0]*arr[k][1]*arr[j][1];
  				if(dp[i][j]==0||dp[i][j]>temp){
  					dp[i][j]=temp;
  				}
  			}
  		}
  	}
  	cout<<dp[1][n];
  } 
  ```

  