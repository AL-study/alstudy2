# 8895. 막대 배치 

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞은 사람 | 정답 비율 |
| :-------- | :---------- | :--- | :--- | :-------- | :-------- |
| 1 초      | 256 MB      | 876  | 488  | 391       | 58.886%   |

## 문제

높이가 1, 2, ..., n인 막대 n개가 일렬로 배치되어 있다. 막대를 왼쪽이나 오른쪽에서 보면, 큰 막대가 뒤에있는 작은 막대를 가리게 된다. 아래와 같이 4개의 막대로 이루어진 두 배치를 살펴보자.

![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/upload/images/polearr.png)

위의 두 배치는 모두 왼쪽에서 봤을 때 막대가 한 개 보이고, 오른쪽에서 봤을 때는 막대가 두 개 보인다.

막대의 개수 n과 왼쪽에서 봤을 때 보이는 막대의 개수 l, 오른쪽에서 봤을 때 보이는 막대의 개수 r이 주어진다. 이때, 이러한 결과를 만드는 배치의 개수를 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, n, l, r이 주어진다. (1 ≤ l, r ≤ n ≤ 20)

## 출력

각 테스트 케이스마다, 입력으로 주어진 값에 해당하는 배치의 수를 출력한다.



## 예제 입력 1 복사

```
4
4 1 2
4 1 1
5 2 4
20 2 1
```

## 예제 출력 1 복사

```
2
0
4
6402373705728000
```



- 점화식만 나오면 간단하게 풀리지만 점화식을 생각하는 과정이 어렵다. (~~골드인 이유가 있습니다.~~)
- 문제를 읽고 규칙을 찾을 수 있을 것 같다는 생각이 들었다. 그래서 DP로 접근했고, 점화식을 생각해봤지만 결국 생각하지 못했다.
- 먼저 생각해야 하는 변수는 총 3개이다. 막대의 개수, 오른쪽에서 봤을 때의 개수, 왼쪽에서 봤을 때의 개수.
  따라서 dp배열의 정의를 다음과 같이 세울 수 있다.
  `dp[n][l][r]=n개의 막대에 대해 왼쪽에서 보이는 막대가 l개 오른쪽에서 보이는 막대가 r개일 때 경우의 수`
- 대부분의 dp가 그렇듯이 하위 문제를 생각하면서 규칙을 찾으면 좀 더 수월하다.  핵심은 **길이가 1인 막대를 어디에 놓는지** 이다. 다음과 같이 분류할 수 있다.
  1. 길이가 1인 막대가 맨 왼쪽에 있다.
     - 이 경우,  가장 작은 막대가 왼쪽에 있기 때문에, n-1개의 막대에 대하여 왼쪽에서 봤을 때 l-1개, 오른쪽에서 봤을 때 r개가 보이는 경우의 수를 구하면된다. 즉, `dp[n-1][l-1][r]`을 구하면 된다.
  2. 길이가 1인 막대가 맨 오른쪽에 있다.
     - 1번의 경우와 같은 논리로 `dp[n-1][l][r-1]`을 구하면 된다.
  3. 길이가 1인 막대가 가운데 있다. (나머지 경우)
     - 중간에 있기 때문에 r과 l에 영향을 주지않는다 그러나 막대의 개수는 줄어들기 때문에 
       `dp[n-1][l][r]`을 구하면 된다.

- n과 l과 r이 모두 필요하기 때문에 총 3번의 for문이 필요하다. 주의 할 점은 초기값인데, n=1, l=1, r=1 일 경우의 수를 생각해보자

- ```c++
  #include <iostream>
  using namespace std;
  int N,R,L,T;
  long long dp[21][21][21];
  int main(){
  	dp[1][1][1]=1;
  	for(int n=2;n<=20;n++)
  		for(int l=1;l<=20;l++)		
  			for(int r=1;r<=20;r++)
  				dp[n][l][r]=dp[n-1][l-1][r]+dp[n-1][l][r-1]+(n-2)*dp[n-1][l][r];
  	cin>>T;
  	for(int i=0;i<T;i++){
  		cin>>N>>L>>R;
  		cout<<dp[N][L][R]<<"\n";
  	}
  }
  ```

  