### 2011. 암호코드 ★

- 알파벳에 각각 번호를 붙여 암호를 만들었을때 만들수 있는 경우의 수를 구하는 문제. 점화식을 유추하는 과정과 예외처리가 어려웠다. 코드는 짧지만 오랜시간 고민했다.

- 먼저 dp를 정의하자. `dp[i]= i개로 만들수 있는 암호의 수`이다. 

  2가지 경우가 있다.

   1. i-1번째의 숫자와 i번째 숫자를 따로 보는 경우. ex) 1,2
      따로 보기때문에 **이전의 숫자에 현재 숫자를 단순히 합쳐주기만 하면된다.** 따라서 `dp[i]+=dp[i-1]`이된다.

   2. i-1번째의 숫자와 i번째숫자를 합쳐서 보는 경우. ex) 12

      이 경우도 1번과 마찬가지다. 다만, i-1번째와 i번째를 합치기 때문에 **i-2번째에 단순히 숫자를 합쳐주는 것과 같다.** 따라서 `dp[i]+=dp[i-2]`가 된다.

- 이제 이러한 경우가 되는 조건을 찾아주자. 2개를 합칠 땐 반드시 10보다 크거나 같고 26 (끝값인 Z가 26이기 때문이다.)보다 작거나 같아야한다.

- 1개를 합칠땐 0이 아니면된다. 따라서 1보다 크거나 같고, 9보다 작거나 같아야 한다.

- ```C++
  #include <iostream>
  using namespace std;
  string str;
  int dp[5010];
  int main(){
  	cin>>str;
  	dp[0]=1;
  	for(int i=1;i<=str.length();i++){
  		int x=str[i-1]-'0';
  		if(1<=x && x<=9){
  			dp[i]=dp[i-1]%1000000;
  		}
  		if(i==1)continue;
  		int y=(str[i-2]-'0')*10+(str[i-1]-'0');
  		if(10<=y && y<=26){
  			dp[i]=(dp[i]+dp[i-2])%1000000;
  		}
  	}
  	cout<<dp[str.length()];	
  }
  ```

  