### 11066. 파일 합치기 ★★

- 소설의 각 챕터의 페이지수가 주어졌을때, 인접한 챕터를 합치면서 하나의 책으로 만들수 있는 최소값을 구하는 문제.

-  인접한 챕터만 합칠 수 있기때문에 정렬을 해서 그리디적인 방법으로 풀지 못한다. 여러 경우로 집합을 나누어 생각해 접근한다. 예를들어 {10,80,90,20}이 주어졌을 경우는 다음과 같이 나누어 생각할 수 있다.

  1.  10 / 80, 90, 20 ( `/`로 집합의 경계를 나누었고 첫번째 집합(10)을 묶고 두번째 집합의(80,90,20)을 묶어서 합을 계산한다.)
  2.  10, 80 / 90, 20 
  3. 10, 80, 90 / 20

- 2개의 집합을 나누고 각 집합을 먼저 묶는다음 최종적으로 2개의 묶음을 묶어 책을 완성하는 것이다.

- dp의 정의는 다음과 같다.
  **`dp[i][j]=i부터 j까지 묶을경우의 최소합`**

- 주의사항은 다음과 같다.

  - 최솟값을 구해야하기 때문에 dp값을 충분히 큰 수로 초기화한다.
  - `dp[i][j]=dp[i][mid]+dp[mid+1][j]`가 아니라 `dp[i][j]=dp[i][mid]+dp[mid+1][j]+sum[j]-sum[i-1]`이다. 각 묶음의 합을 더한 이후 i부터 j까지 부분합을 더해주어야 최종 비용이되기 때문이다.

- 모든 집합을 나누고 dp를 구하는 과정을 떠올리는게 어려웠다. 새로운 유형이라 아직 낯설다. 어려웠던만큼 익숙해지려면 연습이 필요할 것같다. (~~많이 풀어서 혼내주자~~)

- ```c++
  #include <iostream>
  #include <climits>
  using namespace std;
  int t,n,dp[501][501],arr[501],sum[501];
  int main(){
  	cin>>t;
  	for(int l=0;l<t;l++){
  		cin>>n;
  		for(int i=1;i<=n;i++){
  			cin>>arr[i];
  			sum[i]=sum[i-1]+arr[i];
  		}
  		for(int k=1;k<n;k++){
  			for(int i=1;i+k<=n;i++){
  				int j=i+k;
  				dp[i][j]=INT_MAX;
  				for(int mid=i;mid<j;mid++){
  					dp[i][j]=min(dp[i][j],dp[i][mid]+dp[mid+1][j]+sum[j]-sum[i-1]);
  				}
  			}
  		}
  		cout<<dp[1][n]<<"\n";
  	}
  } 
  ```

- #### 참고 출처 :  https://js1jj2sk3.tistory.com/search/11066 

  