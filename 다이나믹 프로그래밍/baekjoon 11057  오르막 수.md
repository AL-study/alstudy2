### 11057. 오르막 수

- 길이가 n개인 오르막수(같은수도 허용)의 개수를 구하는 문제.

- 점화식이 복잡하다. (~~dp가 무려 3중 for문~~)  이런류의 점화식은 쉽게 떠오르지 않기 때문에 써보면서 규칙을 찾는편이 수월하다. 점화식의 최종값으로 찾기보단 어떻게 값이 도출되는지 식으로 규칙을 찾아야 한다.

- 그림을 그려보면 수월하다. 그려보면 0부터 9까지 각각 같은 패턴을 갖고 있음을 알 수 있다. 예를들어 0의 경우, `dp[n][0]=dp[n-1][0]+dp[n-1][1]+dp[n-1][2]+...+dp[n-1][9]`이며, 1의 경우, `dp[n][1]=dp[n-1][1]+dp[n-1][2]+...dp[n-1][9]`이다. 여기까지 생각했다면 규칙이 보일 것이다. 그런데 0부터 9까지 각각의 경우마다 더해야하는 갯수가 다르다. 해당수부터 끝까지(9)더해야하기 때문이다. 따라서 for문으로 갯수를 조절하면서 다음과 같은 코드가된다.

- ```c++
  #include <iostream>
  using namespace std;
  int n,dp[1001][10];
  int main(){
  	for(int i=0;i<10;i++){
  		dp[1][i]=1;
  	}
  	for(int i=2;i<=1000;i++){
  		for(int j=0;j<10;j++){
  			for(int k=j;k<10;k++){
  				dp[i][j]=(dp[i][j]+dp[i-1][k])%10007;
  			}
  		}
  	}
  	cin>>n;
  	int ans=0;
  	for(int i=0;i<10;i++){
  		ans=(ans+dp[n][i])%10007;
  	}
  	cout<<ans;
  }
  ```

  