### 1520. 내리막길★★

- DP배열을 선언해 2중 for문으로 완전탐색하며 4방향을 탐색할 경우, 밑에서 위로, 왼쪽에서 오른쪽으로 방향을 반영하지 못한다.

- BFS로 하나씩 탐색하여 경우의 수를 더해줄 경우 시간초과가 발생한다.

- 따라서 DFS+DP를 이용하여 접근한다. DFS를 이해하고 있다고 생각했는데 정답코드를 보고 오랜시간 이해했다. 다음과 같은 구조를 갖는다.
  1. dp값을 -1로 초기화해 방문하지 않았음을 표시해준다. 
  2. 찾으려는 값인 n행m열의 값부터 dfs를 시작한다. (인덱스는 0부터 시작이기 때문에 n-1,m-1이다.)
  3. 해당 값이 -1일경우 (탐색하지 않았을 경우) 0으로 바꿔주고 (탐색했다는 표시를 해주는 것이다. 해당 경우의 수만큼 더해주기 위해 0으로 초기화한다.) 4방향을 탐색한다. 끝에서부터 0,0까지 거슬러 올라가기 때문에 이동했을때 낮은 값이아닌 높은 값을 찾는다. 조건에 맞을 경우 해당 dp배열에 dfs(이동한행,이동한열)값을 저장한다.  `dp[r][c]+=dfs(mr,mc)` 부분이다.
  4. 이후 해당값을 리턴한다.
  5. 0,0인덱스까지 갔다면 1을 리턴한다. (0,0까지 도달한 순간부터 dp의 값이 더해지게된다.)

- 0,0을 방문하지 못했다면 더해주더라도 해당값은 0이기때문에 값에 영향을 미치지 않을 것이다. 재귀적으로 돌아가는 알고리즘을 설계하는것은 어렵게 느껴진다. 코드는 직관적으로 보일지 몰라도 연쇄적으로 발생되는 여러 조건들을 처리해주어야 하기때문이다.

- ```c++
  #include <iostream>
  using namespace std;
  int n,m,arr[500][500],dp[500][500];
  typedef struct DIR{
  	int r,c;
  }DIR;
  DIR dir[4]={{1,0},{0,-1},{-1,0},{0,1}};
  int dfs(int r,int c){
  	if(r==0&&c==0){
  		return 1;
  	}
  	if(dp[r][c]==-1){
  		dp[r][c]=0;
  		for(int i=0;i<4;i++){
  			int mr=dir[i].r+r;
  			int mc=dir[i].c+c;
  			if(0<=mr&&mr<n&&0<=mc&&mc<m){
  				if(arr[r][c]<arr[mr][mc]){
  					dp[r][c]+=dfs(mr,mc);
  				}	
  			}
  		}
  	}
  	return dp[r][c];
  }
  
  int main(){
  	cin>>n>>m;
  	for(int i=0;i<n;i++){
  		for(int j=0;j<m;j++){
  			cin>>arr[i][j];
  			dp[i][j]=-1;
  		}
  	}
  	cout<<dfs(n-1,m-1);
  }
  
  ```

- #### 참고출처: [우투리와 툴툴]( https://wootool.tistory.com/83 )

  