### 12015. 가장 긴 증가하는 부분 수열2 ★★

- [가장 긴 증가하는 부분 수열]( https://www.acmicpc.net/problem/11053 )과 같은 문제지만 다른 접근방법을 사용해야 한다.

- 다이나믹 프로그래밍 파트에 있지만 다이나믹보다 **이분 탐색**에 가까운 문제였다.

- 기존의 가장 긴 증가하는 부분 수열은 dp배열을 이용해 해당 인덱스보다 낮은 인덱스를 탐색하여 최대값을 찾고 결과값을 저장하는 변수를 갱신하는 방식을 사용했다. 배열의 길이가 1000으로 작은 크기였기 떄문에 for문으로 2번돌려 O(N^2)의 시간복잡도였어도 가능했다. 그러나 이번 문제는 배열의 길이가 1,000,000으로 작지 않은 크기이기 떄문에 결과적으로 시간초과가 발생한다. 따라서 이분탐색을 이용하여 접근해야 한다.

- 벡터를 선언하여 차례대로 값을 받아 벡터를 갱신시키며 벡터에 최종적으로 가장 긴 증가하는 부분 수열을 저장한다. 과정은 다음과 같다.

  1. v(벡터)가 비어있거나, arr[i]가 v의 마지막 값(back)보다 클 때 arr[i]를 v에 push한다.
  2. 1.이 아니라면 lower_bound(크거나 같은 원소의 첫 위치)를 찾아서 그 위치에 있는 원소를 arr[i]로 대체한다.

- 가장 긴 증가하는 부분 수열1을 dp로 풀어서 정해는 다이나믹 프로그래밍이라고 생각했는데 이렇게 이분탐색을 통해 풀 수 있다는 사실에 놀랐다. (심지어 코드도 더 간결하다!) 비슷한 유형의 문제를 만나면 이런 접근방법을 떠올릴 수 있을지 모르겠다. 많은 연습이 필요할 것 같다.

- ```c+
  #include <iostream>
  #include <algorithm>
  #include <vector>
  using namespace std;
  int n;
  vector<int> v;
  int main(){
  	cin>>n;
  	for(int i=0;i<n;i++){
  		int num;
  		cin>>num;
  		if(v.empty()||v.back()<num){
  			v.push_back(num);
  		}else{
  			vector<int>::iterator it=lower_bound(v.begin(),v.end(),num);
  			*it=num;
  		}
  	}
  	cout<<v.size();
  }
  ```

  